% !TEX root = ../thesis-example.tex
%
\chapter{Implementierung}
\label{sec:impl}
Dieses Kapitel beschreibt, wie das Konzept aus Kapitel \ref{sec:konzept} umgesetzt wurde. Es wird sowohl auf die selbst implementierten Operatoren, als auch auf die von mir verwendeten RapidMiner Operatoren eingegangen. 

\section{RapidMiner Studio}
\label{sec:impl:rms}

Die Plattform für das Parser-Framework wurde auf RapidMiner Studio festgelegt. Hierbei handelt es sich um eine Data Science Plattform, in der Operatoren im Steckkasten-Prinzip miteinander verbunden werden. Zwischen diesen Operatoren werden Daten in unterschiedlicher Form übergeben. Die Operatoren selbst führen verschiedene Aufgaben aus. Das eigentliche RapidMiner Studio bietet hauptsächlich Operatoren für die Verarbeitung von Tabellen an. Allerdings sind über den RapidMiner Marketplace auch eine Vielzahl von Erweiterungen erhältlich. Im Rahmen dieser Arbeit wird die Text Processing Extension %TODO ref text processing ext, ref https://rapidminer.com/products/studio/ 
verwendet. RapidMiner bietet zusätzlich die Möglichkeit eigene Operatoren zu programmieren, was im Rahmen dieser Arbeit auch genutzt wurde. Das Studio, die Erweiterungen und die eigenen Operatoren wurden in Java geschrieben. \\

\subsection{Verwendete Operatoren}

Hier werden die bereits bestehenden Operatoren, die ich im Prozess verwendet habe, beschrieben. 

Zum Einlesen des Parser-Modells wurde der Operator \textbf{Read File} aus dem Ordner \textit{Utility\textbackslash Files} verwendet. Dieser hat als Parameter den Pfad, für die zu öffnende Datei. Er bietet einen Output-Port, über den die geöffnete Datei später als \textit{com.rapidminer.operator.nio.file.SimpleFileObject} verarbeitet werden kann. Das Dateiformat der Modelle ist \textit{.bin} für den OpenNLP-Parser, \textit{.gr} für den Berkeley-Parser und \textit{.ser.gz} für den Stanford-Parser. Wichtig ist hier aber nicht die geöffnete Datei, da alle Parser diese selbst nochmal öffnen. Die Parser bekommen als Übergabe den Pfad und dieser kann aus dem \textit{SimpleFileObject} entnommen werden.

Aus der Text-Processing-Extension wird der Operator \textbf{Read Document} verwendet. Er wird an zwei Stellen verwendet. Zum einen wird über ihn der Input-Text für den Parser eingelesen. Zum anderen wird der Goldstandard für die Evaluierung damit in den Prozess gebracht. In beiden Fällen wird nur der Parameter \textit{file} auf den entsprechenden Dateipfad gesetzt und alle anderen Parameter auf ihrem Default-Wert belassen. Auch sein Input-Port wird nicht verwendet. Über den Output-Port wird die geöffnete Datei als \textit{com.rapidminer.operator.text.Document} an die nachfolgenden Operatoren übergeben.

Der letzte verwendete Operator ist \textbf{Execute Script} aus dem Ordner \textit{Utility\textbackslash Scripting}. Dessen Aufgabe ist das Ausführen von Java Code. Verwendung findet er lediglich in Kombination mit dem Stanford-Parser. Die verwendeten Packages von Stanford werden hier einmal initialisiert, da es sonst einen Fehler seitens RapidMiner gibt. Hierfür wird ein Objekt der Klasse  \textit{edu.stanford.nlp.trees.TreebankLanguagePack} erstellt und wieder auf \textit{null} gesetzt. Weder die Input- noch die Output Ports des Operators werden genutzt, wodurch er vor den anderen Operatoren ausgeführt wird, und die Stanford-Packages korrekt initialisiert werden. Um diese Strategie der Fehlerumgehung nutzen zu können sind zwei zusätzliche Schritte notwendig. Zum einen muss die Datei \textit{stanford-parser.jar}, welche die entsprechenden Packages beinhaltet, in den lib Ordner von RapidMiner Studio gelegt werden. Diesen findet man typischerweise unter \textit{Programme\textbackslash RapidMiner\textbackslash RapidMiner Studio\textbackslash  lib}. Das zweite und schwerwiegendere Problem ist der Bedarf einer Large License von RapidMiner. Für die Dauer dieser Arbeit wurde mir diese von RapidMiner kostenlos zur Verfügung gestellt. Der reguläre Preis beträgt allerdings %TODO in Philipps BA nachsehen!
.

\subsection{Eigene Operatoren}

Hier werden die Operatoren und alle dazu gehörigen Klassen, die für dieses Parser-Framework entwickelt wurden, vorgestellt. 

